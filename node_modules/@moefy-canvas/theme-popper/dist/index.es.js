var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _angle, _speed, _renderCount, _rotate, _particles, _shape, _size, _numParticles, _board, _booms, _running, _canvasOptions, _eventsHandler, _listen, listen_fn, _unlisten, unlisten_fn, _handleMouseDown, handleMouseDown_fn, _handleResize, handleResize_fn, _handleVisibilityChange, handleVisibilityChange_fn, _startAnimation, startAnimation_fn;
import { DrawBoard } from "@moefy-canvas/core";
export * from "@moefy-canvas/core";
import { Random, EventsHandler, showBadge, isMobile, isTouchEvent } from "@moefy-canvas/utils";
import { debounce } from "ts-debounce";
class Particle {
  constructor(origin, speed, size, color, angle) {
    __privateAdd(this, _angle, void 0);
    __privateAdd(this, _speed, void 0);
    __privateAdd(this, _renderCount, void 0);
    this.size = size;
    this.color = color;
    __privateSet(this, _renderCount, 0);
    __privateSet(this, _angle, angle);
    __privateSet(this, _speed, speed);
    this.position = __spreadValues({}, origin);
  }
  move() {
    this.position.x = Math.sin(__privateGet(this, _angle)) * __privateGet(this, _speed) + this.position.x;
    this.position.y = Math.cos(__privateGet(this, _angle)) * __privateGet(this, _speed) + this.position.y + __privateGet(this, _renderCount) * 0.3;
    __privateWrapper(this, _renderCount)._++;
  }
  shouleRemove(canvasSize) {
    return this.position.x < 0 || this.position.x > canvasSize.width || this.position.y > canvasSize.height;
  }
}
_angle = new WeakMap();
_speed = new WeakMap();
_renderCount = new WeakMap();
class Circle extends Particle {
  draw(ctx, canvasSize) {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}
class Star extends Particle {
  constructor(origin, size, speed, color, angle) {
    super(origin, size, speed, color, angle);
    __privateAdd(this, _rotate, 0);
  }
  draw(ctx, canvasSize) {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    const R = this.size * 2;
    const r = this.size;
    for (let i = 0; i < 5; i++) {
      ctx.lineTo(Math.cos((18 + 72 * i - __privateGet(this, _rotate)) / 180 * Math.PI) * R + this.position.x, -Math.sin((18 + 72 * i - __privateGet(this, _rotate)) / 180 * Math.PI) * R + this.position.y);
      ctx.lineTo(Math.cos((54 + 72 * i - __privateGet(this, _rotate)) / 180 * Math.PI) * r + this.position.x, -Math.sin((54 + 72 * i - __privateGet(this, _rotate)) / 180 * Math.PI) * r + this.position.y);
    }
    ctx.fill();
    __privateSet(this, _rotate, __privateGet(this, _rotate) + 5);
  }
}
_rotate = new WeakMap();
class ParticleFactory {
  static create(shape, origin, speed, size, color, angle) {
    const Shape = this.shapeMap.get(shape);
    const shapeToCreate = new Shape(origin, speed, size, color, angle);
    return shapeToCreate;
  }
}
ParticleFactory.shapeMap = /* @__PURE__ */ new Map([
  ["star", Star],
  ["circle", Circle]
]);
class Boom {
  constructor(shape, origin, size, numParticles) {
    __privateAdd(this, _particles, void 0);
    this.stopped = false;
    __privateSet(this, _particles, /* @__PURE__ */ new Set());
    for (let i = 0; i < numParticles; i++) {
      const particle = ParticleFactory.create(shape, origin, Random.randomFloat(1, 6), size, Random.color("89ABCDEF"), Random.randomFloat(Math.PI - 1, Math.PI + 1));
      __privateGet(this, _particles).add(particle);
    }
  }
  move(canvasSize) {
    for (const particle of __privateGet(this, _particles)) {
      if (particle.shouleRemove(canvasSize)) {
        __privateGet(this, _particles).delete(particle);
        continue;
      }
      particle.move();
    }
    if (__privateGet(this, _particles).size === 0) {
      this.stopped = true;
    }
  }
  draw(ctx, canvasSize) {
    for (const particle of __privateGet(this, _particles)) {
      particle.draw(ctx, canvasSize);
    }
  }
}
_particles = new WeakMap();
var PopperShape = /* @__PURE__ */ ((PopperShape2) => {
  PopperShape2["Star"] = "star";
  PopperShape2["Circle"] = "circle";
  return PopperShape2;
})(PopperShape || {});
class Popper {
  constructor({ shape = "star", size = 2, numParticles = 10 } = {}, canvasOptions = {}) {
    __privateAdd(this, _listen);
    __privateAdd(this, _unlisten);
    __privateAdd(this, _handleMouseDown);
    __privateAdd(this, _handleResize);
    __privateAdd(this, _handleVisibilityChange);
    __privateAdd(this, _startAnimation);
    __privateAdd(this, _shape, void 0);
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _numParticles, void 0);
    __privateAdd(this, _board, null);
    __privateAdd(this, _booms, /* @__PURE__ */ new Set());
    __privateAdd(this, _running, false);
    __privateAdd(this, _canvasOptions, void 0);
    __privateAdd(this, _eventsHandler, new EventsHandler());
    __privateSet(this, _shape, shape);
    __privateSet(this, _size, size);
    __privateSet(this, _numParticles, numParticles);
    __privateSet(this, _canvasOptions, canvasOptions);
    this.animate = this.animate.bind(this);
  }
  mount(el) {
    __privateSet(this, _board, new DrawBoard(el, window.innerWidth, window.innerHeight, true, true, __privateGet(this, _canvasOptions)));
    __privateMethod(this, _listen, listen_fn).call(this);
    showBadge("Theme Popper \u{1F389}", { leftBgColor: "#ffb366" });
  }
  unmount() {
    __privateMethod(this, _unlisten, unlisten_fn).call(this);
    __privateSet(this, _running, false);
  }
  animate() {
    __privateSet(this, _running, true);
    if (__privateGet(this, _booms).size === 0) {
      __privateSet(this, _running, false);
      __privateGet(this, _board).clear();
      return;
    }
    requestAnimationFrame(this.animate);
    for (const boom of __privateGet(this, _booms)) {
      if (boom.stopped) {
        __privateGet(this, _booms).delete(boom);
        return;
      }
      boom.move(__privateGet(this, _board).size);
    }
    __privateGet(this, _board).draw((ctx, canvasSize) => {
      for (const boom of __privateGet(this, _booms)) {
        boom.draw(ctx, canvasSize);
      }
    });
    __privateGet(this, _board).render();
  }
}
_shape = new WeakMap();
_size = new WeakMap();
_numParticles = new WeakMap();
_board = new WeakMap();
_booms = new WeakMap();
_running = new WeakMap();
_canvasOptions = new WeakMap();
_eventsHandler = new WeakMap();
_listen = new WeakSet();
listen_fn = function() {
  if (isMobile()) {
    __privateGet(this, _eventsHandler).add("touchstart", __privateMethod(this, _handleMouseDown, handleMouseDown_fn).bind(this));
  } else {
    __privateGet(this, _eventsHandler).add("mousedown", __privateMethod(this, _handleMouseDown, handleMouseDown_fn).bind(this));
  }
  __privateGet(this, _eventsHandler).add("visibilitychange", __privateMethod(this, _handleVisibilityChange, handleVisibilityChange_fn).bind(this));
  __privateGet(this, _eventsHandler).add("resize", debounce(__privateMethod(this, _handleResize, handleResize_fn).bind(this), 500));
  __privateGet(this, _eventsHandler).startAll();
};
_unlisten = new WeakSet();
unlisten_fn = function() {
  __privateGet(this, _eventsHandler).stopAll();
  __privateGet(this, _eventsHandler).clear();
};
_handleMouseDown = new WeakSet();
handleMouseDown_fn = function(event) {
  const currentPosition = {
    x: isTouchEvent(event) ? event.touches[0].clientX : event.clientX,
    y: isTouchEvent(event) ? event.touches[0].clientY : event.clientY
  };
  const boom = new Boom(__privateGet(this, _shape), __spreadValues({}, currentPosition), __privateGet(this, _size), __privateGet(this, _numParticles));
  __privateGet(this, _booms).add(boom);
  __privateGet(this, _running) || __privateMethod(this, _startAnimation, startAnimation_fn).call(this);
};
_handleResize = new WeakSet();
handleResize_fn = function(event) {
  __privateGet(this, _board).handleResize(event);
};
_handleVisibilityChange = new WeakSet();
handleVisibilityChange_fn = function(event) {
  __privateGet(this, _booms).clear();
  __privateSet(this, _running, false);
};
_startAnimation = new WeakSet();
startAnimation_fn = function() {
  requestAnimationFrame(this.animate);
};
export { Popper, PopperShape };
