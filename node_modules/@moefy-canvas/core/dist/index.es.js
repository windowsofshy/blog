var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _rawSize, _hd, _canvas, _offscreenCanvas;
class Theme {
  constructor(themeConfig, canvasOptions) {
  }
}
const MAX_Z_INDEX = 2147483647;
const _Canvas = class {
  constructor(el, width, height, hd = true) {
    __privateAdd(this, _rawSize, void 0);
    __privateAdd(this, _hd, void 0);
    __privateSet(this, _rawSize, { width: 0, height: 0 });
    const { el: el_, ctx } = _Canvas.initCanvas(el);
    this.el = el_;
    this.ctx = ctx;
    __privateSet(this, _hd, hd);
    this.size = { width: width || window.innerWidth, height: height || window.innerHeight };
  }
  get size() {
    return __spreadValues({}, __privateGet(this, _rawSize));
  }
  set size({ width: newWidth, height: newHeight }) {
    var _a;
    if (__privateGet(this, _rawSize).width === newWidth && __privateGet(this, _rawSize).height === newHeight) {
      return;
    }
    __privateGet(this, _rawSize).width = newWidth;
    __privateGet(this, _rawSize).height = newHeight;
    const dpr = (_a = __privateGet(this, _hd) ? window.devicePixelRatio : 1) != null ? _a : 1;
    this.el.width = Math.round(__privateGet(this, _rawSize).width * dpr);
    this.el.height = Math.round(__privateGet(this, _rawSize).height * dpr);
    this.el.style.width = __privateGet(this, _rawSize).width + "px";
    this.el.style.height = __privateGet(this, _rawSize).height + "px";
    __privateGet(this, _hd) && this.ctx.scale(dpr, dpr);
  }
  clear() {
    _Canvas.clearCanvas(this.ctx, __spreadValues({}, __privateGet(this, _rawSize)));
  }
  to(canvas) {
    canvas.ctx.drawImage(this.el, 0, 0, __privateGet(this, _rawSize).width, __privateGet(this, _rawSize).height);
  }
  handleResize(_) {
    this.size = { width: window.innerWidth, height: window.innerHeight };
  }
  static setCanvasStyle(canvas, canvasOptions, canvasSize) {
    const style = canvas.style;
    const { zIndex = 0, opacity = 1 } = canvasOptions;
    style.position = "fixed";
    style.top = "0";
    style.left = "0";
    style.zIndex = zIndex.toString();
    style.width = (canvasSize ? canvasSize.width : canvas.width).toString() + "px";
    style.height = (canvasSize ? canvasSize.height : canvas.height).toString() + "px";
    opacity !== 1 && (style.opacity = opacity.toString());
    style.pointerEvents = "none";
  }
  static initCanvas(el) {
    if (!el) {
      el = document.createElement("canvas");
    }
    const ctx = el.getContext("2d");
    return {
      el,
      ctx
    };
  }
  static createOffscreenCanvas() {
    return new _Canvas();
  }
  static clearCanvas(ctx, canvasSize) {
    const { width, height } = canvasSize;
    ctx.clearRect(0, 0, width, height);
  }
};
let Canvas = _Canvas;
_rawSize = new WeakMap();
_hd = new WeakMap();
class DrawBoard {
  constructor(el, width, height, hd = true, useOffscreenCanvas = true, canvasOptions = {
    zIndex: 0,
    opacity: 1
  }) {
    __privateAdd(this, _canvas, void 0);
    __privateAdd(this, _offscreenCanvas, void 0);
    __privateSet(this, _canvas, new Canvas(el, width, height, hd));
    Canvas.setCanvasStyle(__privateGet(this, _canvas).el, canvasOptions, { width, height });
    __privateSet(this, _offscreenCanvas, useOffscreenCanvas ? new Canvas(void 0, width, height, hd) : null);
  }
  get size() {
    return __privateGet(this, _canvas).size;
  }
  draw(callback) {
    var _a;
    const drawingCanvas = (_a = __privateGet(this, _offscreenCanvas)) != null ? _a : __privateGet(this, _canvas);
    drawingCanvas.clear();
    callback(drawingCanvas.ctx, __spreadValues({}, drawingCanvas.size));
  }
  render() {
    if (!__privateGet(this, _offscreenCanvas)) {
      return;
    }
    __privateGet(this, _canvas).clear();
    __privateGet(this, _offscreenCanvas).to(__privateGet(this, _canvas));
  }
  handleResize(event) {
    __privateGet(this, _canvas).handleResize(event);
    __privateGet(this, _offscreenCanvas) && __privateGet(this, _offscreenCanvas).handleResize(event);
  }
  clear() {
    __privateGet(this, _canvas).clear();
    __privateGet(this, _offscreenCanvas) && __privateGet(this, _offscreenCanvas).clear();
  }
}
_canvas = new WeakMap();
_offscreenCanvas = new WeakMap();
export { DrawBoard, MAX_Z_INDEX, Theme };
