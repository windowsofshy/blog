var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _size, _canvasOptions, _eventsHandler, _board, _angle, _listen, listen_fn, _unlisten, unlisten_fn, _handleResize, handleResize_fn, _handleMouseDown, handleMouseDown_fn, _redraw, redraw_fn, _draw, draw_fn, _drawFold, drawFold_fn, _nextColor, nextColor_fn, _nextY, nextY_fn;
import { DrawBoard } from "@moefy-canvas/core";
export * from "@moefy-canvas/core";
import { EventsHandler, showBadge, isMobile, Random } from "@moefy-canvas/utils";
import { debounce } from "ts-debounce";
class Ribbon {
  constructor({ size = 90 } = {}, canvasOptions = {}) {
    __privateAdd(this, _listen);
    __privateAdd(this, _unlisten);
    __privateAdd(this, _handleResize);
    __privateAdd(this, _handleMouseDown);
    __privateAdd(this, _redraw);
    __privateAdd(this, _draw);
    __privateAdd(this, _drawFold);
    __privateAdd(this, _nextColor);
    __privateAdd(this, _nextY);
    __privateAdd(this, _size, void 0);
    __privateAdd(this, _canvasOptions, void 0);
    __privateAdd(this, _eventsHandler, new EventsHandler());
    __privateAdd(this, _board, null);
    __privateAdd(this, _angle, 0);
    __privateSet(this, _size, size);
    __privateSet(this, _canvasOptions, canvasOptions);
  }
  mount(el) {
    __privateSet(this, _board, new DrawBoard(el, window.innerWidth, window.innerHeight, true, true, __privateGet(this, _canvasOptions)));
    __privateMethod(this, _listen, listen_fn).call(this);
    __privateMethod(this, _redraw, redraw_fn).call(this);
    showBadge("Theme Ribbon \u{1F397}\uFE0F", { leftBgColor: "#b300b2" });
  }
  unmount() {
    __privateGet(this, _board).clear();
    __privateMethod(this, _unlisten, unlisten_fn).call(this);
  }
}
_size = new WeakMap();
_canvasOptions = new WeakMap();
_eventsHandler = new WeakMap();
_board = new WeakMap();
_angle = new WeakMap();
_listen = new WeakSet();
listen_fn = function() {
  if (isMobile()) {
    __privateGet(this, _eventsHandler).add("touchstart", __privateMethod(this, _handleMouseDown, handleMouseDown_fn).bind(this));
  } else {
    __privateGet(this, _eventsHandler).add("mousedown", __privateMethod(this, _handleMouseDown, handleMouseDown_fn).bind(this));
  }
  __privateGet(this, _eventsHandler).add("resize", debounce(__privateMethod(this, _handleResize, handleResize_fn).bind(this), 500));
  __privateGet(this, _eventsHandler).startAll();
};
_unlisten = new WeakSet();
unlisten_fn = function() {
  __privateGet(this, _eventsHandler).stopAll();
  __privateGet(this, _eventsHandler).clear();
};
_handleResize = new WeakSet();
handleResize_fn = function(event) {
  __privateGet(this, _board).handleResize(event);
  __privateMethod(this, _redraw, redraw_fn).call(this);
};
_handleMouseDown = new WeakSet();
handleMouseDown_fn = function(_) {
  __privateMethod(this, _redraw, redraw_fn).call(this);
};
_redraw = new WeakSet();
redraw_fn = function() {
  __privateGet(this, _board).draw((ctx, canvasSize) => {
    __privateMethod(this, _draw, draw_fn).call(this, ctx, canvasSize);
  });
  __privateGet(this, _board).render();
};
_draw = new WeakSet();
draw_fn = function(ctx, canvasSize) {
  const { width, height } = canvasSize;
  const foldMark = [
    { x: 0, y: height * 0.7 + __privateGet(this, _size) },
    { x: 0, y: height * 0.7 - __privateGet(this, _size) }
  ];
  while (foldMark[1].x < width + __privateGet(this, _size))
    __privateMethod(this, _drawFold, drawFold_fn).call(this, ctx, foldMark);
};
_drawFold = new WeakSet();
drawFold_fn = function(ctx, foldMark) {
  const size = __privateGet(this, _size);
  const p1 = foldMark[0];
  const p2 = foldMark[1];
  const p3 = { x: p2.x + Random.randomFloat(-0.25, 1.75) * size, y: __privateMethod(this, _nextY, nextY_fn).call(this, p2.y) };
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.lineTo(p3.x, p3.y);
  ctx.closePath();
  ctx.fillStyle = __privateMethod(this, _nextColor, nextColor_fn).call(this);
  ctx.fill();
  foldMark[0] = p2;
  foldMark[1] = p3;
};
_nextColor = new WeakSet();
nextColor_fn = function() {
  const pi_2 = Math.PI * 2;
  __privateSet(this, _angle, __privateGet(this, _angle) + pi_2 * 0.02);
  __privateSet(this, _angle, __privateGet(this, _angle) % pi_2);
  return "#" + (Math.cos(__privateGet(this, _angle)) * 127 + 128 << 16 | Math.cos(__privateGet(this, _angle) + pi_2 / 3) * 127 + 128 << 8 | Math.cos(__privateGet(this, _angle) + pi_2 / 3 * 2) * 127 + 128).toString(16).padStart(6, "0");
};
_nextY = new WeakSet();
nextY_fn = function(y) {
  const { width: _, height } = __privateGet(this, _board).size;
  const t = y + Random.randomFloat(-1.1, 0.9) * __privateGet(this, _size);
  return t > height || t < 0 ? __privateMethod(this, _nextY, nextY_fn).call(this, y) : t;
};
export { Ribbon };
